# Database Persistence Specification

## 1. Purpose
To provide a mechanism for persisting chat conversations to a local database, allowing users to review and resume past conversations. This enhances user experience by preserving chat history across sessions.

## 2. Functional Requirements
- The system must save all messages from both the user and the agent.
- Each conversation session must be stored with a unique identifier.
- The application must be able to retrieve a list of all past conversations.
- The application must be able to load a full conversation history for a given conversation.
- The persistence layer must be integrated with the `MultiAgentOrchestrator`.

## 3. Non-functional Requirements / Constraints
- **Database:** A single SQLite database file will be used for simplicity and local-first operation.
- **Location:** The database file should be stored in a user-specific application data directory.
- **Performance:** Database operations should be asynchronous to avoid blocking the main application thread.
- **Data Integrity:** Migrations will be managed by Alembic to ensure schema consistency.

## 4. Architecture & Data Flow
- **ORM:** SQLAlchemy will be used for database interaction.
- **Models:** Pydantic will be used for data validation and defining the structure of objects, which will then be mapped to SQLAlchemy models.
- **Migration:** Alembic will manage database schema evolution.

### Data Models
- **`Conversation`**:
    - `id`: `UUID` (Primary Key)
    - `created_at`: `datetime`
    - `updated_at`: `datetime`
    - `title`: `str` (e.g., first user message)
- **`Message`**:
    - `id`: `UUID` (Primary Key)
    - `conversation_id`: `UUID` (Foreign Key to `Conversation.id`)
    - `role`: `str` (e.g., 'user', 'assistant')
    - `content`: `str`
    - `timestamp`: `datetime`
    - `metadata`: `JSON` (for extra data like tool calls)

### Flow
1. When a new chat begins, a new `Conversation` record is created in the database.
2. For each message sent by the user or generated by the agent, a `Message` record is created and linked to the current `Conversation`.
3. The `MultiAgentOrchestrator` will be responsible for calling the persistence service to save messages.
4. New API endpoints will be created to list conversations and retrieve messages for a specific conversation.

## 5. Implementation Notes
- A new service/module for database operations should be created.
- SQLAlchemy's async support (`asyncio`) should be used.
- Pydantic models can be used for API request/response validation and then converted to/from SQLAlchemy models.
- Alembic setup will require a `migrations` directory and configuration.

## 6. Deployment Strategy & Environments
- For local development, the SQLite file can be stored in the project root or a `data` directory.
- In production (within OrcaSlicer), the path to the database file must be configurable and point to a stable user data location.

## 7. Acceptance Criteria
- Unit tests for the persistence service (create, read operations).
- Integration tests to verify that chat sessions are correctly saved and retrieved via API calls.
- Alembic migrations are successfully generated and applied.

## 8. Out of Scope
- Real-time synchronization across multiple clients.
- Database encryption (can be considered for a future iteration).
- UI for managing chat history (this is a subsequent feature).

## 9. Risks & Mitigations
- **Risk:** Database schema changes breaking older application versions.
    - **Mitigation:** A robust migration process using Alembic.
- **Risk:** Large database file size impacting performance.
    - **Mitigation:** Implement a pruning or archiving strategy in the future if needed. For now, it's out of scope.

## 10. Future Considerations
- Adding a feature to allow users to name/rename conversations.
- Adding search functionality for chat history.
- Implementing database encryption for enhanced security.
